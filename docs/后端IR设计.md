# 后端 IR 设计

## IR 设计

只考虑一个文件即一个程序的情况。
前端经过预处理等等操作之后传递到后端的可以看作是一个单文本程序,也就是一个 Program.

Program 由 GlobData 和 Function 组成。

- GlobData 包括全局变量和全局常量,提供快速查找接口
- Function 由代码块组成,Function 入口为一个固定的代码块
- 代码块由一条条指令组成。指令可以分为跳转指令 和 数据操作指令
- 代码块的每个指令如果是跳转指令则由该指令有跳转边属性
- 指令中包含操作数: 一个操作数可能是一个具体数字或者一个虚拟寄存器

考虑到 riscv 指令特点都是指令指挥修改一个寄存器或者 0 个寄存器中的数据
设计指令列表如下:

数据操作(移动)指令

| 后端 IR              | rv64gc 汇编         | 其他 |
| -------------------- | ------------------- | ---- |
| ADD $dst $src1 $src2 | add,addw            |      |
| LOAD                 | ld                  |      |
| STORE                | sd                  |      |
| MUL                  | mul / add(乘法优化) |      |
| DIV                  | div                 |      |
| MV                   | mv                  |      |

流程控制指令:
| 后端 IR | rv64gc 汇编 | 其他|
| --- | --- | -- |
| Jmp | j | 无条件跳转|
| Call | call | 函数调用|
| Branch $rs1,$rs2,Label| beq,ble,.. | |

## 验证形式

直接生成汇编运行验证

## 输入以及输入解析方式

目标:后端设计应该能够直接读入汇编或者说汇编经过简单处理后的形式
可以在汇编的基础上进行优化,本身可以当作一个汇编优化器使用

## 承担的优化

乘除法优化,块重排,寄存器分配,指令调度

！！！！ 不进行极端优化,避免过重的难看的工程实践,比如针对函数调用上下文的寄存器重分配 或者是 函数分裂 等

## 优化验证机制

1. 研究主流的代码调度优化效果检测方案
2. 单一变量原则 直接上板 执行
