# 后端汇编生成实现

示例说话:

```c # 1.c
int main(){
    return 0;
}
```

使用`riscv64-linux-gnu-gcc-12 1.c -S -o 1.s` 命令编译得到汇编代码 1.s

以下为生成汇编的带注释版

```rv64gc # 1.s
.file	"1.c"                             # 指示这段汇编代码是从源文件1.c生成的
.option pic                              # 指示生成位置无关代码（Position Independent Code），适用于动态链接
.attribute arch, "rv64i2p1_m2p0_a2p1_f2p2_d2p2_c2p0_zicsr2p0_zifencei2p0" # 设置架构属性为rv64i（整数指令集）及其各个扩展版本信息
.attribute unaligned_access, 0           # 设置不支持非对齐访问，即所有内存访问必须是对齐的
.attribute stack_align, 16               # 设置栈必须按16字节对齐
.text                                    # 指示以下是代码段
.align	1                               # 指示代码对齐，对齐值为2的1次幂，即对齐到2字节边界
.globl	main                             # 指定main为全局符号，这样链接器可以看到这个符号
.type	main, @function                  # 指示符号main是一个函数
main:                                   # main函数开始的地方
	addi	sp,sp,-16                    # 将栈指针sp减去16，为局部变量分配空间
	sd	s0,8(sp)                     # 将帧指针s0的当前值保存到栈上，偏移量为8
	addi	s0,sp,16                    # 设置新的帧指针s0为当前栈指针sp加上16,也就是之前的栈顶指针
	li	a5,0                         # 将立即数0加载到寄存器a5
	mv	a0,a5                       # 将寄存器a5的值移动到a0，a0用于存放函数返回值
	ld	s0,8(sp)                     # 从栈上恢复之前保存的帧指针s0的值
	addi	sp,sp,16                    # 释放之前分配的栈空间，将栈指针sp恢复到函数调用前的值
	jr	ra                           # 通过寄存器ra（返回地址）跳转回调用者
	.size	main, .-main                # 指示main函数的大小（结束地址减去开始地址）
	.ident	"GCC: (Ubuntu 12.3.0-1ubuntu1~22.04) 12.3.0" # 包含生成这个汇编文件的编译器版本信息
	.section	.note.GNU-stack,"",@progbits # 指示这个段是为了标记栈是否是可执行的，这里没有标记为可执行，用于安全
```

来个复杂的例子:

```# 1.c
int a=2;
int b[2];
void f1() {}
int main(){
	return 0;
}
```

对应汇编

```# 1.s


```
